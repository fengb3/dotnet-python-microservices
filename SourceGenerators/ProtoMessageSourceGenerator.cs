using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using Fengb3.EasyCodeBuilder.Csharp;
using Fengb3.EasyCodeBuilder.Csharp.OptionConfigurations;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerators;

[Generator]
public class ProtoMessageSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 找到所有类声明节点（有基类/接口列表的）
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is ClassDeclarationSyntax cds && cds.BaseList != null,
                transform: static (ctx, ct) => {
                    var classDecl = (ClassDeclarationSyntax)ctx.Node;
                    var symbol    = ctx.SemanticModel.GetDeclaredSymbol(classDecl, ct) as INamedTypeSymbol;
                    if (symbol == null) return null;

                    var list = new List<(string handler, string message)>();
                    foreach (var iface in symbol.AllInterfaces)
                    {
                        // 只匹配接口名为 IMessageHandler 且为一元泛型接口
                        if (iface.Name == "IMessageHandler" && iface.Arity == 1)
                        {
                            var handlerFull = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            var msgFull     = iface.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            list.Add((handlerFull, msgFull));
                        }
                    }

                    return list.Count > 0 ? list : null;
                })
            .Where(static x => x != null)
            .SelectMany(static (items, _) => items!);

        // 去重并生成源代码
        context.RegisterSourceOutput(provider.Collect(), GenerateDICode);
    }

    private static void GenerateDICode(SourceProductionContext spc, ImmutableArray<(string handler, string message)> items)
    {
        var unique = new HashSet<(string handler, string message)>(items);
        if (unique.Count == 0)
            return;

        var code = Code.Create()
            // .Using("Microsoft.Extensions.DependencyInjection")
            .AppendLine("// <auto-generated />")
            .Namespace(ns => ns.WithName("SourceGenerators.Generated")
                .Public.Static.Class(cls => cls.WithName("MessageHandlerServiceCollectionExtensions")
                    .Public.Static.Method(mth => {
                        mth.WithName("AddMessageHandlers")
                            .WithParameters("this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services")
                            .WithReturnType("IServiceCollection");

                        // handlers
                        mth.AppendLine("// Register Handlers");
                        foreach (var (handler, msgType) in unique)
                        {
                            mth.AppendLine($"services.AddScoped(typeof(global::MicroservicesApp.ApiService.Services.IMessageHandler<{msgType}>), typeof({handler}));");
                        }

                        // parsers
                        mth.AppendLine("", "// Register Parsers");
                        foreach (var (handler, msgType) in unique)
                        {
                            mth.AppendLine($"services.AddSingleton<Func<byte[], {msgType}>>(sp => {msgType}.Parser.ParseFrom);");
                        }

                        mth.AppendLine("", "return services;");
                    })
                )
            
            )
            .Namespace(ns => ns.WithName("MicroservicesApp.ApiService.Services")
                .Public.Partial.Class(cls => cls
                    .WithName("MessageConsumer")
                    .Public.Method(mth => {
                        mth
                            .WithName("StartConsumeAllAsync")
                            .WithParameters("CancellationToken ct = default")
                            .WithReturnType("Task");

                        var idx = 0;
                        var varNames = new List<string>();
                        foreach (var (handler, msgType) in unique)
                        {
                            var taskVariableName = $"t{idx}";
                            mth.AppendLine($"var {taskVariableName} = StartConsumeAsync<{msgType}>(ct);");
                            varNames.Add(taskVariableName);
                            idx++;
                        }
                        mth.AppendLine($"return Task.WhenAll({string.Join(",", varNames)})");
                        mth.AppendLine($".ContinueWith(t => logger.LogError(t.Exception, \"something went wrong when receiving messages\"));");
                    })
                )
            )
            .Build();

        spc.AddSource("MessageHandlerServiceCollectionExtensions.g.cs", SourceText.From(code, Encoding.UTF8));
    }
}